---
title: "Main Simulation"
#output: html_notebook
---

Adapted from Elliott et al. (2014), the simulation incorporates another contagion channel by adding  the fire-sale (liquidation) effect as an additional bankruptcy cost. The detailed setup is as follows:

1. The numbers of assets and organizations (banks) are 100 with each organization having initial wealth of 100, and each asset having initial price at 1.
2. The integration, organization diversification and portfolio diversification (represented by c, d and e respectively) take the grid between 1 to 20.
3. The default threshold, theta, varies from 0.8 to 0.99
4. For every combination of parameters, simulation is performed on 100 iterations (with few exception to have better accuracy)


# Setup
```{r}
n <- 100
m <- 100
iteration <- 1000

c_range <- seq(0.1, 0.9, 0.1)
d_range <- seq(1/3, 20, 1/3)
e_range <- seq(1/3, 20, 1/3)
alpha_range <- c(0, 0.1005, 0.3046, 0.5129, 0.7257, 1.0536)
theta_range <- seq(0.8, 0.99, 0.1)

zero <- matrix(nrow=length(c_range), ncol=length(d_range))

AvFailures1 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))
AvFailures3 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))

AvSomeFailures1 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))
AvSomeFailures3 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))

AvFirstFailures1 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))
AvFirstFailures3 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))

AvNumWave1 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))
AvNumWave3 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))

AvFirstWaveset1 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))
AvFirstWaveset3 <- array(data=zero, dim=c(length(c_range), length(d_range), length(e_range), length(alpha_range), length(theta_range)))
```


# Simulation
```{r}
c_counter <- 0
for (c in c_range){
  c_counter <- c_counter + 1
  
  d_counter <- 0
	for (d in d_range){
    d_counter <- d_counter + 1
    
    alpha_counter <- 0
    for (alpha in alpha_range){
      alpha_counter <- alpha_counter + 1
      
      theta_counter <- 0
      for (theta in theta_range){
        theta_counter <- theta_counter + 1
        
        FirstFailures1 <- 0
        SomeFailures1 <- 0
        NumWave1 <- 0
        FirstWaveset1 <- 0
        TotFailures1 <- 0
    
        FirstFailures3 <- 0
        SomeFailures3 <- 0
        NumWave3 <- 0
        FirstWaveset3 <- 0
        TotFailures3 <- 0
        
        
        for (iter in 1:iteration){
          
          #A construction
          U <- matrix(runif(n*n),nrow=n,ncol=n)
          t <- d/(n-1)
          G <- ((U<t)*1)*(matrix(rep(1,n*n),nrow=n,ncol=n)-diag(n))
          
          colSumG <- colSums(G)
          colSumG <- colSumG + (colSumG==0)*1
          
          #Make it column stochastic
          L <- t(t(G)*(1/colSumG))
          
          #Compute dependency matrix
          C <- c*L + (1-c)*diag(n)
          hatC <- C*diag(n)
          A <- hatC%*%(solve(diag(n)-C+hatC))
          
          #D construction
          tmp <- matrix((runif(m*n)<e/n)*1,nrow=m)
          for (i in 1:m){
            if (sum(tmp[i,])==0){
              tmp2 <- rep(0,m)
              tmp2[sample(1:n, 1, replace=TRUE)] <- 1
              tmp[i,] <- tmp2
             }
          }
          
          #First-------------------------------------------------------------------------------
          #Elliott
          pold <- matrix(rep(1,n),nrow=n,ncol=1)
          underlinev <- (A%*%pold)*theta
          p <- pold
          p[1] <- 0
          fcount <- 0
          v <- A%*%p
          wset <- seq(1,100)[c((v<=underlinev)*1)==1]
          
          while (any(p!=pold)){
            
            fcount <- fcount + 1
            v <- A%*%p
  					pold <- p
  					p <- p*(v>underlinev)*1
          
          }
          
          numberOfFailures1 <- sum(v <= underlinev)
          
          FirstFailures1 <- FirstFailures1 + (fcount >= 1)*1
          SomeFailures1 <- SomeFailures1 + (fcount >= 2)*1
          NumWave1 <- NumWave1 + fcount
          FirstWaveset1 <- FirstWaveset1 + length(wset)
          TotFailures1 <- TotFailures1 + numberOfFailures1

          #Third-------------------------------------------------------------------------------
          
          p <- rep(1, n)
          v <- rep(100, m)
          D <- tmp/rowSums(tmp)*100
          
          total_assets <- colSums(D)
          for (i in 1:m){
            if (total_assets[i]==0){
               total_assets[i] <- 1
            }
          }
          
          underlinev <- (A%*%D%*%p)*theta
          
          #single conditional asset shock
          seeds <- subset((total_assets>0)*1:100, (total_assets>0)*1:100!=0) #pick out nonzero
          seed <- sample(seeds,1)
          p[seed] <- 0
          v <- A%*%D%*%p
          wset <- seq(1,100)[c((v<=underlinev)*1)==1]
          Dnew <- diag(c((v>underlinev)*1))%*%D
          
         
          liquidation <- 0
          fcount <- 0
          while (any(Dnew!=D)){
            
            fcount <- fcount + 1
            liquidation <- liquidation + colSums(D - Dnew)
            port <- liquidation/total_assets
            
            pnew <- p*exp(-alpha*port)
            v <- A%*%Dnew%*%pnew
            
    				D <- Dnew
    				Dnew <- diag(c((v>underlinev)*1))%*%D

         }
       
          numberOfFailures3 <- sum(v <= underlinev)
          
          FirstFailures3 <- FirstFailures3 + (fcount >= 1)*1
          SomeFailures3 <- SomeFailures3 + (fcount >= 2)*1
          NumWave3 <- NumWave3 + fcount
          FirstWaveset3 <- FirstWaveset3 + length(wset) # the number of failures because of first shock
          TotFailures3 <- TotFailures3 + numberOfFailures3
          
      
        }
        
        print(c)
        print(d)
        print(alpha)
        print(theta)
        
        AvFirstFailures1[c_counter, d_counter, alpha_counter, theta_counter] <- FirstFailures1/iteration
        AvSomeFailures1[c_counter, d_counter, alpha_counter, theta_counter] <- SomeFailures1/iteration
        AvNumWave1[c_counter, d_counter, alpha_counter, theta_counter] <- NumWave1/iteration
        AvFirstWaveset1[c_counter, d_counter, alpha_counter, theta_counter] <- FirstWaveset1/iteration
        AvFailures1[c_counter, d_counter, alpha_counter, theta_counter] <- TotFailures1/iteration
        
        AvFirstFailures3[c_counter, d_counter, alpha_counter, theta_counter] <- FirstFailures3/iteration
        AvSomeFailures3[c_counter, d_counter, alpha_counter, theta_counter] <- SomeFailures3/iteration
        AvNumWave3[c_counter, d_counter, alpha_counter, theta_counter] <- NumWave3/iteration
        AvFirstWaveset3[c_counter, d_counter, alpha_counter, theta_counter] <- FirstWaveset3/iteration
        AvFailures3[c_counter, d_counter, alpha_counter, theta_counter] <- TotFailures3/iteration
      }
    }
  }
}
```